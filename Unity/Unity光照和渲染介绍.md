# 			光照和渲染简介

**全局光照（GI）**：全局光照是描述一系列技术和数学模型的术语，以便模拟光线在世界中弹射的复杂行为。

### 实时光照

​	默认情况下，Unity中的光源都是实时光源。这样的光源为场景提供直接光照，并且每帧都会根据场景内当前的状态来更新。提供实时光照，是光源对象最基本的作用，可以用来照亮场景内移动的对象。然而，实时光源提供的光照射线是不会在对象间弹射的。要创建出更真实的场景，就要使用全局光照技术。

### 烘培全局光照（Baked GI lighting）

​	使用烘培全局光照技术，有一个烘培光照的过程，完成后，场景内静态对象上的光照效果会被保存为光照贴图，然后，在运行时，把这些光照贴图覆盖到场景内对象的表面上来得到比较接近真实的光照效果。光照贴图可以包含来自光源的“直接光照”，也可以包含来自其他静态对象弹射过来的”间接光照”。烘培光照在运行时是无法做改变的，所以也被称为“静态”的光照。实时光源产生的光照效果可以叠加在场景内渲染好的光照贴图之上，但是无法修改光照贴图产生的效果。

### 实时全局光照（Realtime GI lighting）

​	由于传统的烘培全局光照无法在运行时光照条件改变的时候进行更新，于是，Unity提供了一种新的叫做实时全局光照的技术，通过这种技术可以产生实时的根据光照变化而变化的全局光照。要获得实时光照的效果，会需要比较大的计算量，为了防止大量的光照计算对设备造成过大压力使得游戏无法正常运行，实时全局光照有一个预计算的阶段，和烘培全局光照的烘培阶段有点类似，这个阶段会对光线的行为进行计算，这个预计算阶段是在开发阶段进行的，毕竟开发阶段的时间还是比较充裕的。

​	大部分情况下，在模拟真实世界光照时我们希望保存进光照贴图中的是间接光照，而这种光照的颜色一般不会变化的太剧烈。Unity的预计算实时全局光照解决方案充分利用了间接光照这个“漫反射”特性。好的光照细节，例如清晰的阴影，最好是通过实时的直接光照计算生成，而不是烘培在光照贴图中的。因为，使用实时全局光照技术场景内对象的阴影是实时生成的，所以，在它的预计算阶段不需要保存很精细的光照细节,因此，实时全局光照预计算生成的光照贴图的分辨率可以比较低。有了这种优化，可以大量的减少运行时全局光照的计算量。有利于我们在运行时修改光源的属性，改变场景内的光照效果。通常，计算全局光照是通过对光源发出的光线进行射线跟踪得到的，而如果这个计算在运行时进行的话，会对游戏性能造成很大压力。所以，Unity把这个计算改在预计算的时候进行。

### 选择全局光照方案

​	虽然，可以在同一个场景中同时使用烘培全局光照和实时全局光照这两个技术，但是并不推荐这样做。因为，同时使用这两项技术方案，不但意味着在运行时的时候会要在显存中保存两份光照贴图集，并且还要shader中对这些贴图进行解码运算，对硬件资源造成很大压力。所以，最好根据项目的需求和运行的目标硬件来选择一种光照技术方案。例如，如果目标硬件是配置比较低的，可以选择烘培全局光照；如果目标硬件是配置比较高的，有不错的显卡，可以使用实时全局光照。

### 开始预计算

​	无论是烘培全局光照还是实时全局光照，你都可以通过光照设置窗口的设置来让Unity编辑器来进行全局光照的预计算过程。你可以选择手动也可以让编辑器自动开始这个过程。但是，首先你的场景中至少要有一个游戏对象是被标记为光照贴图静态的，因为全局光照的预计算主要是针对静态对象进行的。

### 渲染路径

​	Unity支持多种渲染路径技术，一般在新建一个项目的时候，就会决定使用哪种渲染路径技术，Unity默认使用的是前向渲染（Forward Rendering）

##### 	前向渲染（Forward Rendering）


​	在前向渲染中，一个对象针对每一个影响他的光源都会在shader的“pass”中渲染一次，因此，一个对象渲染几次由影响它的光源数目来决定。这种渲染方式的好处是渲染速度很快，并且，相对于其他的渲染技术方式对硬件的要求最低。还有是这种方式提供了很多定制好的光照模型可以使用。它还能有效利用硬件提供的反锯齿技术来改善渲染效果。而这种方式最大的坏处是，每多一个影响对象的光源，就多一次渲染消耗，也就会导致影响对象的光源越多渲染将会越慢。也就意味着使用这种渲染技术时，游戏中不能有过多的光源。所以，当游戏中光源数量很有限的情况下，前向渲染将是一种很好的选择。

##### 	延迟渲染


​	在延迟渲染中，光照效果是延迟到场景内的对象渲染成了屏幕空间的一系列纹理之后再混合进去的。这种渲染方式最本质的好处是，渲染光照效果的消耗将依赖于光照影响的像素比例，而跟光源的数量没什么关系。这就意味着，对游戏场景内的光源数量将不再有限制。同时，也可以看出延迟渲染将有更高的渲染性能。不过，并不是所有硬件都支持延迟渲染。

### 颜色空间

​	在为项目选择好渲染路径方式之后，为项目选择好颜色空间方案也很重要。因为，颜色空间决定了使用什么样的数学算法用于光照计算中的颜色混合，同时，也决定了如何从纹理中读取值。颜色空间对游戏模拟真实世界有很重要的影响。选择什么样的颜色空间，大部分情况由你的游戏的目标平台的硬件决定。

##### 	线性颜色空间

​	使用线性颜色空间进行渲染，渲染效果将更接近现实世界。线性颜色空间的重要优点是，当光源的光照强度线性增强时，传给shader的颜色值也是线性变亮的。线性颜色空间的另一个好处时，它的shader对纹理进行采样得到的颜色值将不会有Gamma补偿，这样在所有渲染管线中的颜色值将是一致的，这样在渲染管线中进行的颜色计算将更加精确，更有利于渲染出接近真实世界的效果。

##### 	Gamma颜色空间

​	使用Gamma颜色空间，当光源的光照强度线性增强时，颜色值会迅速变白。

然而，并不是所有的硬件都支持线性颜色空间，有一些移动设备并不支持线性颜色空间。所以，在选择颜色空间方案时，先确保你的目标平台支持该颜色空间技术。

### HDR（高动态范围）

​	场景相机的“动态范围”决定了相机能采集到的最亮颜色到最暗颜色的范围，所以，你需要根据项目的需求来设置场景相机使用的“动态范围”。可以通过相机组件的设置来决定相机是否启用“HDR”。不过，有些移动平台硬件不支持HDR。而且，如果使用Forward Rendering，则不能使用HDR。HDR 和线性颜色空间配合使用，可以更准确的处理明亮的颜色。

​	Unity中相机默认使用的是低动态范围（LDR）。颜色保存的精度是RGB每个通道使用8bit，于是，每个通道可以表示的值有256种，这样从黑到白整个颜色空间支持16百万种颜色。

​	在现实世界中颜色有无限种可能，远远不止16百万种，其中有些亮度超出了人类可见的范围。类似的，Unity也可以处理光源产生的非常亮的颜色，可能这些颜色无法正常显示在LDR的设备屏幕上，但是这些特别亮的颜色值在有些情况下还是很有用的。当启用了相机的HDR，那么颜色值将使用更高的精度来保存，使得可以处理的颜色空间比原来大很多，而LDR会把太高的亮度的颜色或太暗的颜色直接截断为白色或黑色，因为LDR的精度有限。HDR高精度使得我们保留场景内照亮区和阴影区亮度的不同。HDR还使得我们可以创建一些特别的效果，比如泛光。

​	在LDR情况下，每个颜色通道用8位表示，所以，每个颜色通道只能有256：1的对比度，然而在自然界中太阳光的对比度是50000：1。HDR则能让颜色有更大的范围的对比度。

##### 色调映射（Tone-mapping）

​	在照相的时候会控制曝光来控制照片的亮度，类似的，HDR就是用来控制曝光的，从而使得我们可以看到更多的颜色细节。传统的设备不能完全显示出HDR的颜色，所以需要色调映射技术来调整。

​	tone-mapping原来是摄影学中的一个术语，因为打印相片所能表现出的亮度范围不足以表现现实世界中的亮度域，而如果简单的线性将真实世界的整个亮度域线性压缩到照片所能表现出的亮度域内，则会在明暗两端丢失很多细节，这显然不是所希望的效果，tone-mapping就是为了克服这一情况而存在的。既然相片所能呈现的亮度域有限制则我们可以根据所拍摄场景内的整体亮度通过光圈与曝光时间的长短来控制一个何时的亮度域，这样既保证细节不丢失，也可以使照片不失真。人的眼睛也是相同的原理，这就是为什么当我们从一个明亮的环境突然到一个黑暗的环境时，可以从什么都看不见到慢慢可以适应周围的亮度，所不同的是人眼是通过瞳孔来调节亮度域的。在计算机图形上，为了让图形更真实的显示在显示器上，也需要tone-mapping来辅助。整个tone-mapping的过程就是，首先推算出当前场景的平均亮度，再根据这个平均亮度选取一个合适的亮度域，再将整个场景映射到这个亮度域得到正确的结果。

​	当启用相机的HDR时，必须为相机加上加上ToneMapping 组件脚本，这个脚本可以让你控制多亮的颜色可以被用来转换为可以显示在屏幕上的颜色。

### 反射

​	默认情况下，场景内的对象使用Unity提供的标准shader来进行渲染。标准shader是基于物理特效的shader(PBS)。PBS通过模拟真实世界中材质的物理特性来表现材质上光线的行为。当使用标准shader的时候，根据设置的金属性所有材质都会有相应的反射率。

##### 反射源


​	现在硬件的性能还不足以实时的去捕捉场景内的反射光线，于是通过提前将反射源渲染成一张立方体贴图，然后在运行时渲染的时候把这张贴图混合渲染进物体表面，来达到反射显示反射源的效果。通常，反射源是天空盒，于是会将天空盒渲染成一个立方体贴图，以便运行时可以使用。有时候我们希望反射显示的内容不是天空盒，这时候可以使用反射探针，反射探针可以将探针所处位置周围空间的内容渲染生成一张立方体贴图，用于反射显示。一般情况下，反射源是天空盒，不过，你可以在场景的光照设置窗口修改反射源为你想使用的一张立方体贴图，光照设置中的反射源可以被看作是包围整个场景的一个立方体贴图，场景内所有对象默认都是使用这个反射源，除非在某一个对象旁边有反射探针。

##### 反射探针

​	在场景中，有些对象并不想反射显示天空盒，比如在屋子里的对象，这个时候就可以通过添加反射探针，来使得该对象可以反射显示周围的物体。反射探针的位置决定了生成的立方体贴图是什么样的，也就决定了对象上反射显示内容是什么样的。为了游戏性能考虑，最好不要在场景内放置太多反射探针。在反射探针的属性面板，可以设置反射探针的类型，特别需要注意的是，如果设置反射探针的类型是realtime，将会使得游戏的性能大幅降低，除非有特别的需求一般不会把反射探针的类型设置为realtime，一般都是设置为Baked，烘焙的反射探针有更好的性能表现。对于设置了“Reflection Probe Static”标志的游戏对象，将只对Baked  Reflection Probe可见。“Realtime” Probe可以看见场景内的所有游戏对象，除非对象被剔除了。

### 环境光照

​	环境光对整个场景的亮度有重要的影响，环境光看起来就像是一个对场景内所有对象都有影响的全局光源。环境光在有些情况下非常有用，比如为场景加一些特殊颜色风格效果，或者是让整个场景看起来更明亮。如果不启用任何一种预计算全局光照方案，环境光将不会被游戏对象遮挡，也就是不会有Ambient Occlusion(环境光遮挡)，环境光对场景内的游戏对象将不造成任何影响。所以，要使得环境光生效，必须使用烘培全局光照或者实时全局光照。环境光渲染消耗非常少。

### 光源

##### 平行光源

​	平行光源，类似于现实世界中的太阳，对游戏场景中的对象来说是一个处于无限远处的光源，这种光源的位置没有任何意义，它朝一个方向发出平行光，发出的光不会衰减，它可以照亮场景内所有的游戏对象，除非对象被剔除了。平行光源可以被用来模拟日出日落效果。

##### 点光源

​	点光源，类似于火把，以点光源所在位置为中心向空间内所有方向发出光线，光的强度随着离点光源的距离越远衰减的越快，当超出点光源照亮的范围，将无法接收到点光源发出的光。如果开启点光源的投影，性能消耗将非常大。因为，点光源的产生的阴影需要在游戏空间的6个方向上都渲染一次，这在比较慢的设备是无法接收的，所以，点光源很少开启阴影。值得注意的是，点光源不支持实时的间接弹射光遮挡，意思是，当使用实时全局光照技术时，点光源会为间接光照产生贡献，但是，由于点光源不支持实时的间接弹射光遮挡，点光源产生的光线会透传过前面一个物体而在这个物体后面的物体间弹射，这样就会出现光线泄漏的问题，除非刚才提到的背后的物体不在点光源的照射范围之内，因为，超出了点光源的照射范围，点光源的光照强度衰减为零了，这样的话就不会出现光线泄漏的现象。平时在摆放配置点光源要特别注意，避免出现光线泄漏的问题。不过，如果使用烘培全局光照则不会出现这个问题。

##### 聚光灯光源

​	聚光灯光源在z轴的正方向上投射一个圆锥体形的光锥，它发射的光线的光强度随着离光源越远衰减的越快，同时，以圆锥体中心线朝扇形两边光线强度也会衰减。同样的，和点光源一样，聚光灯光源在使用实时全局光照的时候，也不支持实时的间接弹射光遮挡，也就意味着它也会出现透传过一个物体，在另一边进行弹射的光线泄漏问题，所以，在摆放配置聚光灯光源的时候也要特别注意。

##### 区域光源

​	区域光源是一个矩形光源，光线固定的朝z轴正方向发射，光线均匀的通过它的表面，它的照射范围不能修改，由系统控制，光照的强度随着离光源的距离越远衰减越快。这个光源只有在烘培全局光照的时候才有用。

### 自发光材质

​	区域光源只支持烘培全局光照，在实时全局光照中无法使用。不过，我们可以通过自发光材质来实现和区域光同样的柔光效果。类似区域光源，自发光材质发射的光线也是均匀的通过它的表面，它没有照射范围的设定，不过，同样的，它发射的光的强度也是随着离发光材质越远衰减的越快。因为，自发光材质可以实时全局光照的时候使用，所以，它可以在运行时根据需要调整光强度和颜色。并且，自发光材质也可以在烘培全局光照的时候使用。Unity提供的标准shader有‘Emission’属性，可以通过配置'Emission'，使得材质变成自发光材质，这样使用这个材质的静态对象，就变成了自发光的了，可以为场景贡献直接光照和间接光照。自发光材质的光只能被场景内静态对象接收到，如果场景内的动态对象想要接收到自发光材质发出的光，必须借助光照探针的辅助才能接收到自发光材质的光。如果设置自发光材质的对象不是静态的，那么它的光将对场景内的对象没有任何影响，只是它自己变的更亮了。默认情况下，Unity标准shader中emission的值是0，表示该材质不会自发光，可以把这个值改为大于零，让材质自发光，并且emission是支持值大于1的，也就是说是支持HDR的。在烘培或者预计算之后，看起来自发光材质会为静态对象提供直接光照，跟平行光源等光源有点像，但是在不进行烘培或预计算生成光照贴图数据的情况下，自发光材质只是自己变亮，不会对场景内周围的对象造成影响，这样又跟光源完全不同，我的理解是，自发光材质只能影响静态对象或者通过光照探针影响动态对象，所以，推测自发光材质的光效是依赖于烘培或预计算生成的光照贴图数据才能产生效果的。自发光材质产生的光不能产生阴影。

### 光照探针

​	Unity烘培或预计算全局光照时，只会考虑场景内的静态对象。如果希望场景内的动态对象也可以像静态对象那样可以接收到场景内丰富的弹射光，我们需要把空间内的光照信息记录保存下来，然后在运行时把这些信息交给光照公式来使用，从而使得动态对象也可以受到弹射光影响。我们可以在场景内放置一些采样点，采样点抓取该点所有方向的光照以及颜色信息保存下来，以供运行时使用，这些采样点就是光照探针。动态对象的网格渲染器会去查找当前位置周围的光照探测点，光照探测点会组成很多四面体，动态对象通过判断在哪个四面体内，找到相关联的光照探测点。如果没有光照探针，动态对象将无法接收全局光照，这样可能会导致动态对象跟场景看起来不是一个整体。有一点需要注意的是，通过光照探针接收到的全局光照，不能让动态对象产生阴影。光照探针也可以影响静态对象。

### 环境遮挡（Ambient Occlusion）

​	在现实世界中两个表面连接处颜色会更深，往往是更暗，例如墙角。3D游戏世界中使用环境遮挡技术来模拟这种效果，使得两个表面连接处颜色更深。之所以，两个表面连接处的更暗，猜测是因为两个表面连接处由于光照产生阴影，而阴影往往是暗色调，而这种暗色的光又在两个面之间来回弹射，于是暗色叠加会导致看起来更暗，这是猜测理解，尚未查找标准解释。环境遮挡的一种解释，随着物体与物体的接近，它们来自环境的散射光越来越少，相近的表面就形成了阴影，而且环境光遭遇到的阻碍越多，阴影的色调就越暗。Unity的光照设置面板中，在光照贴图的设置部分，有启用环境遮挡的选项，开启环境遮挡功能之后，有具体的配置环境遮挡效果的参数，Max Distance是指衰减的最远距离，超过这个距离，环境遮挡将不可见，Indirect Contribution是指和间接光照的对比度，这个值越大则环境遮挡与间接光照对比度越大，环境遮挡也越暗越明显，Direct Contribution是指和直接光照的对比度，这个值越大则环境遮挡和直接光照的对比度越大，环境遮挡也越暗越明显。



### 特别需要注意的光照设置

##### Scale In Lightmap

​	在需要烘培的静态对象的MeshRender组件上有关于光照贴图的设置Lightmap settings，其中有一项是Scale In Lightmap，这个参数决定了这个对象在烘培出的光照贴图中所占的空间，当对象在光照图中占用较小的空间，也就意味着，这个对象的所生成的光照贴图尺寸较小，于是，其运行时的光照效果分辨率会比较低。有些情况下，这个配置很有用，例如那些离摄像机较远的对象，根本就不需要高分辨率的光照效果，于是可以把这个参数设置的比较低，而适当为对象设置一个较小的scale in lightmap参数，可以有效的减少整个场景光照贴图的大小。对于有些时候，某一个对象只需要投影到场景中，而对象本身不需要接收全局光照，这时候就可以把这个对象的scale in lightmap参数设为0，使得光照贴图不用保存关于这个对象的光照信息。虽然光照贴图中没有这个对象的光照信息了，但是这个对象还可以受光照探针的影响，从光照探针那里活动全局光照。

