### ECS模式和Entitas

#### 介绍ECS模式
##### ECS简介 
ECS是一种设计模式，它强调组合优于继承的设计法则。 

E、C、S分别指代其最重要的三个元素。E表示Entity，称为实体，作为组件的容器，可以拥有一个或者多个组件，用一个32bit ID表示，它的意义主要用来进行生命周期的管理；C表示Component，称为组件，组件中只存有表示特定属性的状态数据；S表示System,称为系统，系统中只有操作组件中数据的方法，一个系统只关心处理某一类或几类组件。ECS模式核心思想就是用这三种元素来组合构建世界。

传统的OOP思想是世界中的一切皆对象，把数据和行为封装成对象来构造世界；而ECS思想和其最大的区别就是，把数据和行为分离，不再封装在一起，把数据拆分成各种组件，把行为拆分成各个子系统，而实体则负责把多个组件组合起来变成有意义的单元，当实体中的组件经过系统的处理之后也就意味着实体完成了一次行为。

在ECS架构中，把每个可能单独使用的对象属性归纳为一个个Component，比如对象的位置状态就可以成为一个Component,每个Entity由多个Component组合而成，共享一个生命周期；每个System则是个高内聚专注于干好一件事的模块，操作Entity中的Component。我们可以把多个Component组合在一起作为System的筛选器，当System只关心某一个固定的Component的组合时，ECS框架就把世界中满足有这个组合的Entity都筛选出来供交给这个System，然后这个System就操作这些Entity中的Component，从而完成功能，不满足这个组合的Entity将被忽略。在ECS中，每个系统关注的是一个Entity的集合，这些Entity拥有共性的切片。
##### ECS优点
1. 模式简单，结构清晰。可以简化依赖的管理，主要处理好系统和组件的关系即可。
2. 容易组合，高度复用。通过组合可以有效的消除由于复杂的继承关系导致程序难以理解、维护和扩展的问题。
3. 扩展性强。
4. 灵活性更高。可以通过在运行时为实体增删组件来改变实体能实现的功能，极大的提高了灵活性。
5. 数据驱动编程，利于保证游戏世界的正确性。
6. 利于网络同步。
##### ECS使用问题及注意事项
1. 系统间的通信问题。通常系统间的通信是通过把数据保存在组件中来进行通信。但是，如果系统间有很多事件需要通信，而且这些事件都发生的不太频繁，那么将导致增加很多专门用来通信的组件，还会导致系统再每次update的时候都要去检查一下相应的组件数据，这样将降低程序的运行效率。所以，我们在实现ECS框架的时候有必要加入观察者模式来解决这种系统间的通信问题，使得事件发生时，才通知观察者来处理。
2. 系统的更新次序问题。有可能某些功能会出现一个系统的更新执行需要依赖另一系统先执行才能得到正确结果，这就意味着两个系统出现了耦合，在设计的时候应该尽量避免出现这样的系统，但可能实际情况是无法完全规避这种情况，这算是ECS模式的一个缺陷，所以，我们要注意确保系统更新次序的正确性。
3. 有些Component全局有且仅有一个，比如玩家键盘输入Component。对于这种Component可以创建单例Component放入世界中供全局访问，系统不再需要通过遍历Entity去找出这种Component，这样可以节省计算资源。不过，在使用单例Component时要慎重，避免滥用。
4. 有时候，多个系统中可能出现需要处理同一类问题的情况，而处理这种共性问题的行为又不好设计成系统，这时可能就会需要把处理方法抽离出来作为工具函数，供全局共享使用。例如计算两个实体间的敌对关系的问题，如果设计成系统来处理，可能就会把所有的实体间的敌对关系都运算一遍，这可能是没必要的，纯粹是浪费资源。
5. 很多系统可能会导致组件中的状态数据改变，产生副作用，在设计系统的时候，应该尽量使得将状态改变表现出来的系统延迟执行。
6. ECS是用来实现纯逻辑的，因此，需要把游戏引擎获得各种输入，例如用户操作输入、物理引擎输入等，都转成Component来交给ECS来进行处理，然后由ECS中的系统把处理后的数据交给游戏引擎来生成结果反馈给用户。
7. ECS中的系统需要大量的遍历来查找符合条件的实体以及组件，而且很多系统每帧都会执行，所以，可能会对性能有一定的消耗。于是，需要ECS框架做好实体和组件的管理，以便高效的查找。
##### ECS框架实现注意事项
1. 遍历实体时的消耗问题。如果每次都遍历所有实体来找系统需要处理的组件的话，那么当实体数量比较大时，每次udpate为所有系统查找组件都将导致大量的时间消耗。所以，在实现ECS框架的时候，可以选择按组件类型类分组存储组件，这样在为系统查找组件时将极大的提高效率。也可以考虑增加其他方法来提高遍历的效率。
### 为什么要做Unity中使用ECS
>Unity引擎提供的设计模式是Entity-Component模式，是一种组件模式，也是强调组合优于继承。
  - 游戏对象可以通过增删组件来实现功能的添加删除。
  - 组件可以在不同的游戏对象间复用。
  - 数据驱动，数据改变，游戏状态可以立即更新。

>但是，Unity中的组件依旧是数据和行为的封装。
  - 开发到后期，随着需求的越来越复杂，组件可能会过度膨胀。
  - 组件间有依赖的时候，方法不清楚该放入哪个组件中。
  - 多个组件互相依赖之后，将很难实现单个组件的服用。
#### 介绍Entitas框架
Entitas是用C#实现的，为Unity引擎设计的快速而轻量级的ECS框架。
##### Entitas帮助完成的功能
1. 基础ECS世界的实现。只需要根据需求创建及组合Component、Entity、System即可。
2. 负责管理及缓存各种Component，尽量使得System获取所感兴趣的Component的速度更快，同时避免过多的对象创建销毁而导致垃圾回收时会出现的卡顿现象。
3. 提供代码生成器，减少手写的代码量。
##### Entitas使用简要指南
* Context：管理器。所有Entity、Component和System都必须通过Context进行创建，然后Context对它们进行管理。允许有多个Context存在，一般一个Context代表一个逻辑世界。
* Group：Entity的管理组。用来加速具有某一个Component组合的Entity查询，Group会根据Entity拥有的Component，及时更新其中的Entity。Group有OnEntityAdded、OnEntityRemoved、OnEntityUpdated三个事件可以订阅，Group会在适当的时候通知观察者。
* Matcher：Entitas定义的一个小的特定领域语言，用来描述具有某一特定Component组合的Entity的查询条件，从而可以从Context中查询得到满足条件的Group。
* Collector：Entity收集器。用于监测具有某组Component的Group中Entity的变化事件。需要注意的是，如果收集器订阅的是Removed事件，然后Removed事件触发Entity被收集之后，这个Entity又加上了同一个组件，那么这个Entity又会被加回到Group中，但是这个Entity依旧在收集器中，所以Collector有一个Filter方法，用来确认Entity是否要过滤掉。
* Index：索引，可以通过给组件中的数据加上某种Index标签，就可以在查询Entity的时候，指定特定的值来过滤掉不必要的Entity。因为Entitas内部实现会用加了Index标签的数据的值为Entity建一张索引表。
* System：
  - IExecuteSystem:只有一个Execute方法，每帧都会执行这个方法
  - ICleanupEystem:只有一个Cleanup方法，周期性的执行方法，这个系统在所有IExecuteSystem之后执行,用于清理工作。
  - InitializeSystem接口：有Initialize方法,只执行一次，游戏初始化的工作可以在Initialize方法中完成。
  - ITearDownSystem接口：有TearDown方法，逻辑世界要关闭时，可以实现这个接口，并在TearDown方法中完成最后的清理工作。
  - ReactiveSystem:用于当关注的特定类Entity发生变化时，进行处理，也是在每帧执行Execute方法，不过，只有在当前帧和前一帧之间Entity发生了变化，Execute才会被执行。
    
* Feature:系统的容器，用于把系统划分组织成不同的单元，作为世界中一个个的特性。这样我们可以根据实际需要选择在哪个Update中调度执行系统。
* Attribute:特性标签
  - *ContextName*:Context标签，用来标识Component属于哪个上下文管理器。一种Component允许属于多个Context。
  - *Unique*:唯一标签，用来标识Component，表示拥有这种Component的Entity只能存在一个。对于有些状态数据，只会有一份。
  - *UniquePrefix("prefixName")*:只能用来标记空组件，用来改变空组件对于布尔值属性名的前缀，默认前缀是"is"。
  - *CustomComponentName("Name1,Name2,...")*:这个标签可以用于一次性生成多个拥有同样成员的组件。而不需要去分别定义不同的组件文件，减少多余的编码量。
  - *DontGenerate*:这个标签用于告诉代码生成器，不用为这个组件生成相关代码。
* Component:含有状态数据的组件。根据组件中是否有定义成员，分两种不同的组件。没有定义成员的Component，也就是空组件，属于标记类组件，它们会变成Entity的布尔值属性；另一类就是有定义成员的Component，属于普通的Component。
* Entity
