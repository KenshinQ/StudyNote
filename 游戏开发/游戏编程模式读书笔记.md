### 游戏编程模式读书笔记一

​	游戏开发过程中通常面临三个大需求：

- 游戏架构灵活性
- 游戏运行效率
- 游戏开发速度

  游戏架构的灵活性，可以让Bug的修复以及后续需求的添加都更容易，同时，写出优雅代码是每一个程序员天生的追求；游戏运行效率则可以让游戏有更为广大的受众，是玩家的普遍需求；游戏更快开发速度则可以让游戏的玩法尽快的进入可试玩的状态，方便试错，以便找出更好的玩法，是项目负责人或者说老板的普遍需求。然而，它们之间往往是冲突的，这就需要在开发的时候，权衡好这三个方面需求。所以，游戏开发最好分三个阶段，前期开发原型时，尽量快的开发出功能原型，不需要考虑灵活性和代码质量，中期确定了功能之后，重构代码以保证代码质量和灵活性；后期将发布时，优化运行效率，消除部分灵活性。**解耦的目的或者说好处是什么，就是当我们要查看某部分功能的代码时，我们需要装进脑子里的模块或者代码尽可能的少。**

### 游戏编程模式读书笔记二：命令模式

​	命令模式，是把方法调用实例化或者说对象化，也就是一种回调的面向对象实现。这个模式可以有效的把生成调用的模块和执行调用的模块解耦，也就是生产者和消费者解耦。在游戏开发中，使用这种模式使得为游戏中的人物和怪物生成AI行为更容易，因为完全可以由AI模块为他们产生控制命令；对于有些游戏中需要实现回放战斗的功能，也会更容易实现；还有的是例如如果要支持撤销操作，利用这个模式也可以很方便的实现。

##### 游戏编程模式读书笔记三：享元模式

​	享元模式，是指在多个对象中共享使用同一个对象，从而可以有效的节省内存，因为这种可共享的对象实例中的数据往往是“上下文无关的”，或者说是固有不变的状态。使用这种模式，就可以避免创建一大堆重复的对象数据。例如，游戏场景中的森林渲染，森林中的树木的部分数据像树干树枝树叶网格、树皮树叶纹理都是一样的，就可以只共享一份数据，而不用创建成千上万份；另一个例子是，地形的构造，场景中地表往往分成很多区块，但地形的种类是有限的，所以，不同区块也是可以共享地形数据的。

#####游戏编程模式读书笔记四：观察者模式

​	观察者模式，把对象分为两种角色观察者和被观察者，可以实现观察者和被观察者交流，但是两者不会耦合。观察者可以根据需要订阅自己关心的被观察者的通知，被观察者发布通知，但不用关心到底哪个观察者接受通知。被观察者通常会保留有一个观察者列表，这个列表通常使用数组来实现，但是如果想避免动态分配内存，可以使用链表的方式来实现观察者列表。观察者模式一般都是基于对象的方式来实现的，观察者往往是实现了特定接收通知的接口的对象，然而有时候如果只是为了接收一个通知而把对象变成一个实现特定接口的对象，会觉得不太值得，而且接收不同被观察者的通知一般是同一个接口，然后在接口方法内部来路由。但是，在现代很多语言中函数本身就是一等公民，是作为对象的存在，比如javascript、Lua等，所以，在新时代的语言中，实现观察者模式，可以直接把函数设为观察者。在进行UI开发时，一种新的观察者模式的实现方式是“数据绑定”。

### 游戏编程模式读书笔记五：原型模式

​	原型模式，是指以一个已有的对象为原型，然后以它为模版，通过拷贝它的方式来创建产生新的对象，这样不需要设计专门的生产类来创建特定状态的对象。（暂时没发现使用这个模式有什么其他优点）

##### 游戏编程模式读书笔记六：单例模式

​	单例模式，是用来保证一个类只有一个实例，并且提供访问该实例的全局访问点的模式。这个模式，为整个系统提供了全局共享的状态。但是，我们都知道设计出全局状态对整个工程是非常有害的，而全局访问点，也很容易让这个类耦合进任何一个模块中。所以，我们应该尽量避免使用单例模式。