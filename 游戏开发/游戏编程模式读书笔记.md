### 游戏编程模式读书笔记一

​	游戏开发过程中通常面临三个大需求：

- 游戏架构灵活性
- 游戏运行效率
- 游戏开发速度

  游戏架构的灵活性，可以让Bug的修复以及后续需求的添加都更容易，同时，写出优雅代码是每一个程序员天生的追求；游戏运行效率则可以让游戏有更为广大的受众，是玩家的普遍需求；游戏更快开发速度则可以让游戏的玩法尽快的进入可试玩的状态，方便试错，以便找出更好的玩法，是项目负责人或者说老板的普遍需求。然而，它们之间往往是冲突的，这就需要在开发的时候，权衡好这三个方面需求。所以，游戏开发最好分三个阶段，前期开发原型时，尽量快的开发出功能原型，不需要考虑灵活性和代码质量，中期确定了功能之后，重构代码以保证代码质量和灵活性；后期将发布时，优化运行效率，消除部分灵活性。**解耦的目的或者说好处是什么，就是当我们要查看某部分功能的代码时，我们需要装进脑子里的模块或者代码尽可能的少。**

### 游戏编程模式读书笔记二：命令模式

​	命令模式，是把方法调用实例化或者说对象化，也就是一种回调的面向对象实现。这个模式可以有效的把生成调用的模块和执行调用的模块解耦，也就是生产者和消费者解耦。在游戏开发中，使用这种模式使得为游戏中的人物和怪物生成AI行为更容易，因为完全可以由AI模块为他们产生控制命令；对于有些游戏中需要实现回放战斗的功能，也会更容易实现；还有的是例如如果要支持撤销操作，利用这个模式也可以很方便的实现。

##### 游戏编程模式读书笔记三：享元模式

​	享元模式，是指在多个对象中共享使用同一个对象，从而可以有效的节省内存，因为这种可共享的对象实例中的数据往往是“上下文无关的”，或者说是固有不变的状态。使用这种模式，就可以避免创建一大堆重复的对象数据。例如，游戏场景中的森林渲染，森林中的树木的部分数据像树干树枝树叶网格、树皮树叶纹理都是一样的，就可以只共享一份数据，而不用创建成千上万份；另一个例子是，地形的构造，场景中地表往往分成很多区块，但地形的种类是有限的，所以，不同区块也是可以共享地形数据的。

#####游戏编程模式读书笔记四：观察者模式

​	观察者模式，把对象分为两种角色观察者和被观察者，可以实现观察者和被观察者交流，但是两者不会耦合。观察者可以根据需要订阅自己关心的被观察者的通知，被观察者发布通知，但不用关心到底哪个观察者接受通知。被观察者通常会保留有一个观察者列表，这个列表通常使用数组来实现，但是如果想避免动态分配内存，可以使用链表的方式来实现观察者列表。观察者模式一般都是基于对象的方式来实现的，观察者往往是实现了特定接收通知的接口的对象，然而有时候如果只是为了接收一个通知而把对象变成一个实现特定接口的对象，会觉得不太值得，而且接收不同被观察者的通知一般是同一个接口，然后在接口方法内部来路由。但是，在现代很多语言中函数本身就是一等公民，是作为对象的存在，比如javascript、Lua等，所以，在新时代的语言中，实现观察者模式，可以直接把函数设为观察者。在进行UI开发时，一种新的观察者模式的实现方式是“数据绑定”。

### 游戏编程模式读书笔记五：原型模式

​	原型模式，是指以一个已有的对象为原型，然后以它为模版，通过拷贝它的方式来创建产生新的对象，这样不需要设计专门的生产类来创建特定状态的对象。（暂时没发现使用这个模式有什么其他优点）

##### 游戏编程模式读书笔记六：单例模式

​	单例模式，是用来保证一个类只有一个实例，并且提供访问该实例的全局访问点的模式。这个模式，为整个系统提供了全局共享的状态。但是，我们都知道设计出全局状态对整个工程是非常有害的，而全局访问点，也很容易让这个类耦合进任何一个模块中。所以，我们应该尽量避免使用单例模式。避免使用单例可用的几中优化方法

- 依赖注入---通过外部传入参数的方式，传入需要用到的对象
- 继承获得---利用类的继承，从基类中获得需要用到的对象
- 从已是全局的对象中获取---由尽量少的全局对象来管理，然后从其中获取

##### 游戏编程模式读书笔记七：状态模式

​	状态模式，使用这个模式的情况是，当一个对象的内部状态发生变化时会改变自身的行为，看起来这个对象好像改变了类型。

​	有限状态机（FSM），它的核心是状态、输入和转移，简单来说有四个要点：

- 你拥有状态机所有可能状态的集合
- 状态机同时只能在一个状态
- 一连串的输入或事件发送给状态机
- 每个状态机都有一系列的转移，每个转移与输入和另一个状态相关。当输入进来，如果它与当前状态的某个转移相匹配，状态机转换为所指的状态；如果没有匹配的转移则忽略。

  在有限状态机的基础上，进一步拓展，会用到并发状态机、分层状态机等。并发状态机使用的情况是，对象有可能同时处于两类状态中，所以需要两个状态机同时运作。分层状态机使用的情况是，对象有可能在处于某一类状态的时候，又进入了另一类细分的状态，也就是新的状态是在原来状态的基础上进入了，于是就有了属于父子的层级关系的两个状态机。

  在有的时候，我们希望对象在某一个状态结束之后可以回到之前所处的状态，实现这个需求的数据结构称为下推自动机。通常的实现方式是，使用栈来实现，把对象新的状态入栈，状态结束之后把状态弹出栈，然后回复到上一个状态。

##### 游戏编程模式读书笔记八；双缓冲模式

​	缓冲是指一段可修改的状态，而对缓冲的修改可能是增量的，有一个过程；同时，会有外部的代码需要对缓冲中的内容进行读取，为了防止外部代码读取到错误的状态，我们希望对缓冲的修改是原子性的，也就是在修改的过程中，外部代码不会读取到修改中的缓冲，这个时候我们就需要用到双缓冲模式。双缓冲模式，信息总是从当前的缓冲区中读取；状态的修改总是在下一个缓冲区中进行；当修改完成之后，一个交换操作会立即把当前缓冲区和下一个缓冲区进行交换，这样新缓冲区中的信息就是可读的了，而旧的缓冲区变成了重用的缓冲区。

​	需要用到双缓冲模式的情况一般都会有如下需求：

 -  我们需要维护一些被增量修改的状态

 -  我们修改到一半的时候，状态可能会被外部请求

 -  我们要防止外部请求状态的代码知道内部的工作方式

    -  我们想要读取状态，而且不想等着修改完成

    从上面条件的描述可以看出，主要针对解决的是防止外部访问正在修改的状态的情况；但是，还有一种情况是，防止负责修改状态的代码访问正在修改状态。

    双缓冲模式的缺点有：

    - 交换缓冲区需要时间。在状态修改后，两个缓冲区要交换下，这个交换必须是原子的，在交换的时候任何状态都不可访问，这个交换过程可能需要一定的时间。
    - 要保有两个缓冲区，增加内存的使用量。

##### 游戏编程模式读书笔记九：子类沙箱模式

​	子类沙箱模式，是指基类定义抽象的沙箱方法和一些操作方法，这些操作方法是protected的，然后，沙箱子类使用基类提供的操作方法来实现沙箱函数。这个模式的好处是，基类提供操作方法，所有的子类用这些操作方法来实现逻辑，可以极大的增加代码的复用性；然后，由于操作方法的实现都在基类中实现，这样就可以把和外部系统的耦合留在基类中，可以极大的减少其子类和外部系统的耦合度，方便调整修改。这个模式的坏处也显而易见，由于基类要实现大部分的操作方法供子类调用，基类中的方法会越来越多，整个类会越来越臃肿，甚至可能变成大杂烩。所以，在使用这个模式的时候，一定要注意考虑好哪些方法应该放入基类中，如果基类规模过大时，可以适当的抽离部分操作构造成辅助类。模版方法模式和这个模式正好相反，两个模式都有一系列受限操作方法，不同的是，子类沙箱模式，操作方法在基类中，控制方法（沙箱方法）的实现在子类中；而模版方法模式，操作的实现在子类中，控制逻辑方法（模版方法）的实现在基类中。

##### 游戏编程模式读书笔记十：类型对象模式

​	类型对象模式，是指专门定义一种类型作为类型的模版，它的每一个实例对象代表一种不同的逻辑类型，其实就是类似于python等语言的元类型，于是，当其他的某一系列对象持有对某一个类型对象实例的引用，这些对象便都属于某一类型。利用这种模式，实例相关的数据存储在这些属于某一个类的对象实例中，而被同一类实例对象所共享的数据和行为则存储在类型对象中。用这么模型，可以让对象间共享同类型的数据和行为更灵活，不再是硬编码，当要创建新的类型时将更方便，甚至可以让我们在运行时的时候更加需要创建新的类型。

​	这种模式带来灵活性的同时，也带来了一些缺点和复杂度：

 -  需要手动追踪对象的类型对象。当使用传统的方式，利用语言的类型系统，通过定义各种子类的方式来实现同类的数据和行为共享时，是由编译器帮我们记录类的注册，并在创建实例的时候将实例和类信息关联起来。而使用类型对象模式时，则需要我们来手动管理对象所属的类型，为它配置对应的类型对象，也意味着我们要手动管理好这些类型对象。
 -  比较难为每种类型定义特定的行为。当使用子类派生的方式创建各种类型，你可以通过重载方法的方式，在各种子类中创建各种各样特定的行为，想怎么做就怎么做。但当使用类型对象模式时，方便的是改变类型对象的数据，而很难改变类型对象的行为。要跨越这个限制，一种方法是，预先定义好各种各样的多种行为作为备用，然后类型对象根据其有的数据来选择执行什么样的行为逻辑；另一种方法是，支持由数据来定义行为，比如解释器模式和字节码模式，那样也可以实现改变行为的目标。还有一种方法，就是语言中的函数也是一种对象，那么我们也就可以在运行时的时候像配置数据一样配置类型对象的行为，比如Javascript、Lua等。
 -  为了让类型对象更像类型，一般类型对象都会有构造器，使用类型对象的构造器来创建属于该类型的对象。
 -  也会需要使用继承类分享数据。不过，类型对象的继承和语言的继承不一样，我们可以让类型对象引用另一个类型对象，从而获得另一种类型的数据和行为。



​	类型对象模式处理的高层问题是在多个对象间分享数据和行为，另外一个解决相同问题的模式是原型模式。

​	类型对象模式和享元模式有点类似，两者都可以让你在实例间分享代码，不过，享元模式的目标是通过共享数据从而节约内存，共享的数据可能不代表任何概念上的“类型”；而类型对象模式的目标则重在各不同类型的组织性和灵活性。

​	类型对象模式和状态模式也有些相似之处。两者都是将一个对象的部分定义委托给另一个对象。不同的是，通过类型对象，我们委托的是该对象“是什么”，委托的数据是该对象一些不变的特性；通过状态模式，我们委托的是对象现在“有什么”，委托的数据是描述该对象当前暂时的状态。

##### 游戏编程模式读书笔记十一：组件模式

​	组件模式，是指当一个实体对象拥有不同领域的功能或者说行为，将属于不同领域的数据和行为分离成不同的组件类，让它们彼此隔离，实体对象只是拥有这些组件的容器对象。使用这个模式，我们可以通过在一个容器对象上装配不同的组件来产生不同类型的游戏对象。不过，在使用这个模式进行游戏设计的时候，有一个问题需要注意，那就是实体对象上不同组件间如何进行通信，因为，虽然可能大部分情况下不同组件间是互相隔离不需要通信的，但是，既然它们属于同一个实体对象的组成部分，还是会有部分组件是互相有关联需要通信的。组件间常用的方式有：

- 通过容器对象的状态来通信。它的优点是，充分的保证了不同组件间的解耦，组件只会看见容器对象中的状态，而不知道另一个组件的存在。它的缺点是，要把部分组件间共享的数据保存在容器对象中，而大部分情况下，这些数据只是很少的组件用的到的数据，这样可能会让容器对象中的数据越来越多越来越混乱，更糟糕的情况是，当使用同样的容器对象，但是却用不同的组件配置，那它里面可能会有完全不被任何现有组件使用的数据，这会导致内存浪费。另一个缺点是，这会让组件的通信变成隐含式的，通信过程是一个组件修改容器状态数据以及另一个组件访问容器状态数据的副作用，这个通信的结果严重依赖组件的处理顺序，当容器对象变的复杂之后，这种通信方式可能会导致很难发现的BUG。
- 组件间直接互相访问需要的数据。这种方式的好处是，简单快速。但是，它的缺点也很明显，互相访问的组件将会耦合在一起，跟组件模式的目标是冲突的。
- 通过发送消息的方式。这种方式实现起来会略复杂，需要在容器对象中建立一个消息系统，用于将一个组件发送的消息转发给其他组件，同时组件需要有能接收消息的方法。这种方式的好处是，也达到了让需要互相通信的组件间解耦的目的，它们现在唯一耦合的地方就是消息值；而且，这也可以使得容器对象简化，不用保存过多状态。


​	这个模式和策略模式有点类似，两种模式都是将一类对象的部分行为抽离出来委托给单独的从属对象来实现，不同的是，在策略模式中，策略对象是没有状态的，它只是封装的算法，只负责定义对象有什么样的行为；而组件模式中，组件对象大部分情况下是带有状态的，它通常不但定义了容器对象有什么样的行为，同时也会定义容器对象是什么。当然，有些组件也是无状态的，这样的话，一个组件对象可以被多个容器对象共享，无状态的组件和策略对象没有什么差别。

##### 游戏编程模式读书笔记十二：事件队列模式

​	事件队列模式，是指用一个先进先出的队列来存储一系列事件或消息，事件的发送者发送事件后会立即返回，事件被放进事件队列中，而事件的处理者稍后会从队列中去出事件来处理，这样事件或消息的发送时机就和事件或消息的处理时机解耦了。有了这个队列，使得延迟处理事件、合并事件以及忽略事件可以很方便的做到。事件和消息大部分情况下表示同样的意思，但有些情况下，表述的意思会不同，因为事件往往表示一件已经发生的事件，而消息往往会用于描述将要发生的事情。使用这个模式的时候，有些需要注意的地方，因为发送事件的时刻并不处理事件，而是放进事件队列，稍后再处理，这就意味着，当处理者从事件队列中拿出事件来进行处理的时候，游戏世界的状态很可能早已经不是事件发生时候的那个状态了，所以，为了能获得正确的事件处理结果，这种情况下需要在发送事件的时候截取一个状态数据的快照和事件一起发送，以便处理事件的时候使用；由于使用事件队列是一种异步事件系统，当出现循环事件BUG的时候将比较难发现，像同步事件系统如果出现循环事件问题会因为栈溢出而很快就被发现，所以，通常的设计原则是在处理事件的时候最好不要发送事件。

​	事件队列模式和观察者模式很像，它可以称为异步的观察者模式。

##### 游戏编程模式读书笔记十三：服务定位模式

  服务定位模式，是指在全局提供一个用于获得服务提供者的访问点，隐藏提供服务的具体类以及获得服务提供者的实际过程，这样可以解耦使用服务的类和实际实现服务接口的具体类，因为服务的使用者只看接口，而不关心具体的实现类。在使用这个模式的时候，有几点需要注意，一个是因为服务是向全局暴露的，全局任何模块在任何时候都有可能要获取服务来使用，所以，要不总是能提供一个服务给使用者，要不就是使用者要做错误兼容，允许获取不到服务的情况，如果使用前一种处理方式，那么我们可以专门实现一个什么都不做的空服务，在实际的服务尚未创建的时候，给请求的使用者提供空服务，这样大部分情况下游戏始终能正常运作；另一点是，是否真的需要将服务在全局暴露，如果我们想在有限的范围能使用服务，那么可以根据实际需要设计服务访问点，比如，可以把服务访问点设在一个基类中，使得只有它的子类才能通过访问点获取服务。这个模式的另一个好处是，我们可以在需要的时候替换实际的服务类，而不被使用者所察觉，我们利用这个特性来关闭某一服务或者拓展某一服务将变的更容易。

  这个模式和单例模式类似，两者都提供全局访问服务，不同的是，单例模式确定的类提供服务，而服务定位模式则不对外暴露实现服务的具体类。

  ##### 游戏编程模式读书笔记十四：数据局部性模式
  数据局部性模式，是指通过保证数据以处理的顺序依次排列在连续的内存上，提高内存的局部性，使得CPU读取数据的速度更快，从而提高游戏的性能。因为，现代CPU有缓存来加速内存数据的读取，它可以更快的读取最近访问过的内存毗邻的内存。使用这个模式的情况是，当游戏遇到了性能问题，而且性能问题是由于缓存不命中导致的。软件体系结构的特点之一是抽象，从而尽量解耦，而这也就意味着大量的使用指针或者引用来访问对象、方法等，而使用指针就意味着在内存中跳跃，这必然带来大量的缓存不命中，而缓存不命中正是这个模式所要解决的。所以，使用这个模式就意味着要放弃一定的抽象。这再次证明，软件设计没有完美的模式，只有权衡后相对而言较好的解决方案。
  为了让数据满足局部性，提高缓存命中率，有几种常用的方案：
  - 连续数组。把数据对象保存在连续数组中，方便CPU在读取数据的时候把邻近的数据也对进CPU缓存中。
  - 打包数据。把有效的数据对象移动到一起，把无效的数据对象移动到另一边，使得CPU读取进缓存中的数据都是有效的，提高缓存命中
  - 冷、热数据分离。经常用到的数据称为热数据，很少用到的数据称为冷数据。把很少情况才用到的数据从数据对象中分离出去，用独立的对象保存，而数据对象中只保留指像冷数据的对象的指针，这样就可以减少CPU读取进缓存中无效的数据量，增加有效的数据量，从而增加缓存命中率。

  ##### 游戏编程模式读书笔记十五：脏标记模式
  脏标记模式，是指有一组*原始数据*随着时间变化而改变，而实际使用的是一组由其推导出的一组*导出数据*，这个推导过程往往比较昂贵，于是用一个“脏”标记追踪导出数据是否和原始数据一致。脏标记在原始数据修改的时候被设置，如果导出数据被请求时，该标记被设置了，那么重新计算导出数据并清楚标记，否则的话就使用之前缓存的导出数据。这是一个优化模式，当推导导出数据的计算量的确对性能造成影响时，我们可以用这个模式来减少计算量。这个模式增加了使用导出数据的复杂度，因为，在使用这个模式的时候，一要确保正确的设置脏标记以保持原始数据和导出数据的一致性；二是要额外的内存来保存导出数据。可以说是用内存来换取CPU的运算资源的模式。

  ##### 游戏编程模式读书笔记十六：对象池模式
  对象池模式，是指定义一个池子实例，由它创建并维护一定数量的可重用对象，当需要使用对象的时候从池子中获取，当用完之后还给池子，而不是临时创建对象以及使用完后立即释放对象。目的是改善内存的使用和性能。
    ###### 使用这个模式的原因
    通常我们使用对象的方式是，需要对象的时候请求分配内存来创建对象，对象使用完之后立即释放对象，归还对象所占的内存，看似没有问题，但时间稍长就会有一个比较严重的问题--内存碎片化，内存碎片化会可能会使得总的内存量是够用的，但是由于它们被分割成很多段，当要创建一个占用内存稍大点的对象，就会因为找不到合适的内存段来创建对象，游戏所在进程就会认为内存不足，从而向系统请求分配更多内存，这样也就会导致游戏运行时间稍长游戏所占内存就会越来越大，最后可能被系统杀死。而对象池模式可以避免内存过度碎片化的问题，因为池中一直保有固定数量的对象以供使用，不会频繁的创建销毁对象，也就不会切割内存。对于有垃圾回收机制的语言，内存碎片化的影响可能会没那么大，因为垃圾回收器会定期的回收内存整理内存，让碎片化的内存重新变的连续，但是，垃圾回收也是要消耗CPU时间的，当一次垃圾回收要处理的工作量过大时就会造成游戏卡顿，所以，对象池模式也有利于改善其性能。
    ###### 适合使用这个模式的情况
    - 需要频繁的创建消耗对象的时候
    - 对象所占内存差不多大小
    - 在堆上创建对象速度较慢或容易导致内存碎片化
    - 对象中封装了较昂贵的资源，不适合完全释放后再重建，比如网络连接、数据库连接。

    ###### 这个模式的缺点
    - 会浪费一部分内存在不使用的对象上。因为对象池在初始化的时候就会创建一定数量的对象，这个部分内存在对象池存在的时候都被占用的。而池中有会有对象处于闲置状态，在一定程度上浪费了内存
    - 池中一般只有固定数量的对象可供使用。有可能在同一时间需要的使用的对象过多的时候，导致池中无对象可用，于是无法从池中获取到对象。所以，在使用对象池的时候，要对无法获取到对象的情况进行处理。
    - 回收的对象要记得进行清理工作，使其变的可用。

  这个模式和享元模式看起来有点类似，两者都维护一定数量“重用”的对象。但是，两者“重用”的意思并不相同，享元模式的重用对象是指在多个对象中共享同一个的数据实例，以便共享数据；对象池模式的重用是在一个对象实例生命周期结束后，清理后交给另一个对象使用，不用重新分配内存创建新的对象。

  ##### 游戏编程模式读书笔记十七：空间分区模式
    空间分区模式，是指对于一系列对象，把它们存储在根据它们在世界空间中的位置组织的空间数据结构中，从而使得在查询某处或某处周围的对象时的效率更高。通常游戏世界中有很多有位置的对象，对处于某一位置的对象的查找往往会比较消耗性能，为了减少查找的性能消耗，有必要根据对象的空间位置来组织对象，于是，有了空间分区模式，这个模式可以将O(n)或者O(n2)的操作降到更加可控的数量级，n越大使用这个模式对性能的提升越大。使用这个模式，一个明显的缺点是，对象的位置发生变动的时候，处理将变的跟复杂，因为，对象的位置发生变动后，需要重新组织对应的空间数据结构，以保证空间数据结构也得到更新，以便在之后进行查询是能得到正确的结果。
    空间数据结构大体上分两种划分类型：
    - 平面划分。这种划分实现更简单，实现的空间数据结构是一种扁平的结构，它占用的内存量是确定的，添加新对象的时候不需要增加新的划分，当对象的位置放生改变时，空间数据结构的更新也更快，因为，一般只用把对象从一个分区挪到另一个分区，空间数据结构本身的结构不会发生变化。比如网格结构。
    - 层次划分。这种划分的实现则要复杂的多，它会根据当前划分的各个分区中包含对象的数量动态决定是否进一步划分出子分区，如此递归下去，当对象减少时，也要动态决定是否要合并两个子分区，于是这种划分看起来更像一颗层级树。对于世界空间中存在大片空白区域时，这种划分更高效，因为空白区没有对象也就不会进一步划分；同样的对于有很多对象的区域，这种划分也更高效，因为它会不断的划分子分区，知道分区中对象的数量满足要求。平面划分对于这两种情况都是比较低效的。不过，这种划分在对象的位置发生变化的时候，处理会更复杂，因为它可能会触发数据结构划分的更新。

    常见的空间数据结构有：
    - 网格结构(Grid)。桶排序
    - 四叉树(QuadTree)。多叉树
    - BSP。线性搜索树
    - k-d树(k-d tree)。线性搜索树
    - Bounding volume hierarch。线性搜索树